/** Тестовое задание от 3iTech */
/**  Задание 2. JS
 *  Задача: написать функцию `decode` в том же стиле, что и
 *  функция `encode` (вытянутой в цепочку) и
 *  узнать значение переменной `input`
 * @type {string}
 */

/** Функция encode */
const encode = input => [...input]
    .map((x, i) => [x.charCodeAt(0), i])
    .sort()
    .flatMap(x => x)
    .join('.')
    .match(/./g)
    .flatMap((x, i) => new Array(x == '.' ? 1 : 2 + x * 2).fill((1 + i) % 2))
    .join('')
    .replace(/(([01])\2*)/g, x => `${(+x ? '.' : '-')}${x.length}`)

let str = '.10-12.1-4.2-1.10-12.1-4.2-2.1-10.12-1.4-2.10-1.10-12.1-4.2-18.1-10.12-1.4-4.6-1.10-12.1-4.4-16.1-10.12-1.4-6.6-1.10-12.1-4.6-14.1-10.12-1.4-8.4-1.10-12.1-4.8-14.1-10.12-1.4-10.1-10.12-1.4-10.2-1.10-12.1-4.10-10.1-10.12-1.4-10.18-1.10-12.1-4.12-6.1-10.12-1.4-12.14-1.10-12.1-4.14-4.1-10.12-1.4-14.12-1.10-12.1-4.14-20.1-10.12-1.4-16.8-1.10-12.1-4.16-16.1-10.12-1.4-18.1-10.12-1.6-1.10-12.1-6.6-1.10-12.1-6.16-1.10-12.1-8.4-1.10-12.1-8.14-1.10-12.1-10.2-1.10-12.1-10.10-1.10-12.1-10.20-1.10-12.1-12.8-1.10-12.1-12.16-1.10-12.1-14.1-10.12-1.14-6.1-10.12-1.14-14.1-10.12-1.16-2.1-10.12-1.16-10.1-10.12-1.16-18.1-10.12-1.18-6.1-10.12-1.18-14.1-10.12-1.20-4.1-10.12-1.20-12.1-10.14-1.2-1.10-14.1-4.2-6.1-10.14-1.4-2.14-1.10-14.1-4.4-2.1-10.14-1.4-4.12-1.10-14.1-4.6-1.10-14.1-4.6-2.1-10.14-1.4-6.10-1.10-14.1-4.6-20.1-10.14-1.4-8.10-1.10-14.1-4.8-18.1-10.14-1.4-10.6-1.10-14.1-4.10-14.1-10.14-1.4-12.2-1.10-14.1-4.12-10.1-10.14-1.4-12.18-1.10-14.1-4.14-1.10-14.1-4.14-8.1-10.14-1.4-14.16-1.10-14.1-4.16-4.1-10.14-1.4-16.12-1.10-14.1-4.16-20.1-10.14-1.6-2.1-10.14-1.6-12.1-10.14-1.6-20.1-10.14-1.8-10.1-10.14-1.8-18.1-10.14-1.10-1.10-14.1-10.6-1.10-14.1-10.16-1.10-14.1-12.4-1.10-14.1-12.12-1.10-14.1-12.20-1.10-14.1-14.10-1.10-14.1-14.18-1.10-14.1-16.6-1.10-14.1-16.14-1.10-14.1-18.1-10.14-1.18-2.1-10.14-1.18-10.1-10.14-1.18-18.1-10.14-1.20-8.1-10.14-1.20-16.1-10.18-1.4-8.8-1.10-18.1-4.14-2.1-10.20-1.4-2.4-1.10-20.1-4.2-16.1-10.20-1.4-4.8-1.10-20.1-4.4-14.1-10.20-1.4-4.18-1.10-20.1-4.6-4.1-10.20-1.4-6.16-1.10-20.1-4.8-1.10-20.1-4.8-2.1-10.20-1.4-8.6-1.10-20.1-4.8-12.1-10.20-1.4-10.8-1.10-20.1-4.10-20.1-10.20-1.4-12.16-1.10-20.1-4.14-6.1-10.20-1.4-14.18-1.10-20.1-4.16-6.1-10.20-1.4-16.18-1.10-20.1-4.18-2.1-10.20-1.6-4.1-10.20-1.6-8.1-10.20-1.6-14.1-10.20-1.8-6.1-10.20-1.8-12.1-10.20-1.8-20.1-10.20-1.10-12.1-10.20-1.10-18.1-10.20-1.12-10.1-10.20-1.14-2.1-10.20-1.14-8.1-10.20-1.14-16.1-10.20-1.16-1.10-20.1-16.12-1.10-20.1-16.20-1.10-20.1-18.16-1.10-20.1-18.20-1.10-20.1-20.6-1.10-20.1-20.18-1.12-2.1-4.10-16.1-12.2-1.4-12.20-1.12-2.1-4.16-1.12-2.1-6.10-1.12-2.1-8.1-12.2-1.8-2.1-12.2-1.8-8.1-12.2-1.8-16.1-12.2-1.10-8.1-12.2-1.12-18.1-12.2-1.20-20.1-12.6-1.4-1.12-6.1-4.2-8.1-12.6-1.4-2.20-1.12-6.1-4.4-4.1-12.6-1.4-6.8-1.12-6.1-4.6-12.1-12.6-1.4-8.16-1.12-6.1-4.10-12.1-12.6-1.4-12.1-12.6-1.4-12.4-1.12-6.1-4.16-2.1-12.6-1.4-18.4-1.12-6.1-4.20-1.12-6.1-6.18-1.12-6.1-10.4-1.12-6.1-12.1-12.6-1.12-2.1-12.6-1.12-6.1-12.6-1.12-14.1-12.6-1.14-20.1-12.6-1.16-4.1-12.6-1.16-8.1-12.6-1.18-4.1-12.6-1.18-8.1-12.6-1.20-1.12-6.1-20.10-1.12-6.1-20.14-1.12-10.1-4.4-1.12-10.1-4.4-10.1-12.10-1.4-8.20-1.12-10.1-4.10-4.1-12.10-1.4-12.8-1.12-10.1-4.12-12.1-12.10-1.4-14.14-1.12-10.1-4.16-14.1-12.10-1.14-12.1-12.10-1.18-12.1-12.10-1.20-2.1-12.14-1.4-2.12-1.12-14.1-4.4-20.1-12.14-1.4-6.18-1.12-14.1-4.14-10.1-12.14-1.4-16.10-1.12-14.1-10.14-1.12-14.1-14.4-1.12-14.1-16.16';

/** Обычная функция (function declaration) decode(input)
 *
 */
/*function decode(input) {
    let newStr = input
        .replace(/(\.|)(\d+)/g, (_, t, val) => t === '.' ? '1'.repeat(val) : '0'.repeat(val))
        .match(/([01])\1*!/g)
        .map(x => x.length === 1 ? '.' : (x.length - 2) / 2)
        .join('')
        .match(/\d+\.\d+/g)
        .map(x => x.split('.'))
        .sort((a, b) => a[1] - b[1])
        .map(x => String.fromCharCode(x[0]))
        .join('');

    const regexp = /[a-z]/g;
    const result = newStr.match(regexp);

    if (result !== null) {
        return newStr;
    }

    return decode(newStr);
}

console.log(decode(str)); */

/** Стрелочная рекурсивная функция decode.
 * Декодирует необходимое количество раз,
 * до получения буквенных значений в коде.
 */

/*const decode = (input) => {
    let newStr = input
        .replace(/(\.|)(\d+)/g, (_, t, val) => t === '.' ? '1'.repeat(val) : '0'.repeat(val))
        .match(/([01])\1*!/g)
        .map(x => x.length === 1 ? '.' : (x.length - 2) / 2)
        .join('')
        .match(/\d+\.\d+/g)
        .map(x => x.split('.'))
        .sort((a, b) => a[1] - b[1])
        .map(x => String.fromCharCode(x[0]))
        .join('');

    const regexp = /[a-z]/g;
    const result = newStr.match(regexp);

    if (result !== null) {
        return newStr;
    }

    return decode(newStr);
}

console.log(decode(str))*/

/** Разберем пошагово
 *  Закодируем let a = 'af';
 */
let str1 = 'do';
let input = 'do';
/** 1. Деструктурируем input */
console.log([...input]);
let k = ['d', 'o'];
/** 2. Изменим полученный массив буквенных значений.
 *  Каждую букву запишем в виде кода алфавита
 *  и присвоим ей текущий индекс.
 * @type {[number,number][]}
 */
let l = k.map((x, i) => [x.charCodeAt(0), i]);
console.log(l);
/** Отсортируем
 * @type {[number,number][]}
 */
let m = l.sort();
console.log(m);
/** Уменьшим вложенность (сделаем массив плоским)
 * с помощью flatMap(x => x)
 * @type {number[]}
 */
let n = m.flatMap(x => x);
console.log(n);
/** объединяем все элементы в одну строку через точку
 * @type {string}
 */
let o = n.join('.');
console.log(o);
/** Определим и запишем каждый знак строки в массив по отдельности
 * с помощью match(/./g)
 * @type {RegExpMatchArray}
 */
let p = o.match(/./g);
console.log(p);
/** Каждый элемент полученного массива закодируем с помощью flatMap().fill()
 *  От значения элемента зависит количество повторений (flatMap()) цифры 0 или 1 (fill())
 * @type {any[]}
 */
let r = p.flatMap((x, i) => new Array(x === '.' ? 1 : 2 + x * 2).fill((1 + i) % 2));
console.log(r);
/** объединяем все элементы в одну строку
 * @type {string}
 */
let s = r.join('');
console.log(s);
/** Находим сколько одинаковых цифр идет по порядку.
 *  Перед повторяющимися 1 ставим '.'
 *  Перед повторяющимися 0 ставим '-'
 *  Последовательно записываем количество повторений единиц и нолей.
 * @type {string}
 */
let t = s.replace(/(([01])\2*)/g, x => `${(+x ? '.' : '-')}${x.length}`);
console.log(t);
/** Закодировали 'do' - получили код .4-2.2-1.2-1.4-4.4-1.4 */
/** Закодировали 'af' - получили код .4-2.6-1.4-1.20-16.1-2 */

// Посмотрим как работают некоторые участки кода
/*const point = (x) => `${(+x ? '.' : '-')}${x.length}`;

console.log(point('1111'));
console.log(point('00'));

const u = '11110011111101111';
const regexp22 = /(([01])\2*)/g;
const res = u.match(regexp22);
console.log(res);

console.log(1%2); */

/** Теперь декодируем пошагово в обратном порядке */
/** Для раскодирования достаточно выполнять шаги в обратную сторону. */
/** 1. конечная строка представляет собой список из символов . и -, которые
 *  представляют собой 1 и 0 соответственно и числом, указывающим их количество.
 *   Для их получения можно воспользоваться заменой с регулярным выражением
 *   .replace(/(\.|\-)(\d+)/g, (_, t, val) => t == '.' ? '1'.repeat(val) : '0'.repeat(val))
 *   определяем какой символ и вставляем нужное количество
 * @type {string}
 */
let a = '.4-2.2-1.2-1.4-4.4-1.4';
//let a = '.4-2.6-1.4-1.20-16.1-2';
let b = a.replace(/(\.|)(\d+)/g, (_, t, val) => t === '.' ? '1'.repeat(val) : '0'.repeat(val));
console.log(b);
/** 2.  собираем одинаковые символы в группы: если количество символов четное - это значимое
 *  число - если в группе одна цифра - это точка
 * @type {RegExpMatchArray}
 */
let c = b.match(/([01])\1*/g);
console.log(c);
/** 3.  объединяем все в одну строку - получаем промежуточное представление из чисел
 *  разделенных точками
 * @type {(string|number)[]}
 */
let d = c.map(x => x.length === 1 ? '.' : (x.length - 2) / 2);
console.log(d);
let e = d.join('');
console.log(e);
/** 4. два стоящих числа разделенных точкой - являются значением и индексом. Их можно
 *  получить с помощью регулярного выражения
 *  .match(/\d+\.\d+/g) *
 * @type {RegExpMatchArray}
 */
let f = e.match(/\d+\.\d+/g);
console.log(f);
/** 5. Получить отдельные значения для индекса
 *  .map(x => x.split('.'))
 * @type {string[][]}
 */
let j = f.map(x => x.split('.'));
console.log(j);
/** 6. отсортируем по индексам по возрастанию
 * @type {string[][]}
 */
let h = j.sort((a, b) => a[1] - b[1]);
console.log(h);
/** 7. получить значение символа по коду
 *  .map(x => String.fromCharCode(x[0]))
 * @type {string[]}
 */
let i = h.map(x => String.fromCharCode(x[0]));
console.log(i);
/** 8. объединяем все в одну строку.
 *  Получаем раскодированную строку 'do' или 'af'.
 */
let g = i.join('');
console.log(g);

